<!DOCTYPE html>
<html>
  <head>
    <title>MediaPipe Pose/Stroke Analysis</title>

    <!-- post detection model -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"
      onload="window.ReactNativeWebView.postMessage('Pose loaded');"
      onerror="window.ReactNativeWebView.postMessage('Pose failed to load');">
    </script>
    <!-- drawing landmarks and connections -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"
      onload="window.ReactNativeWebView.postMessage('Drawing utils loaded');"
      onerror="window.ReactNativeWebView.postMessage('Drawing utils failed to load');">
    </script>
    <!-- camera input -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"
      onload="window.ReactNativeWebView.postMessage('Camera utils loaded');"
      onerror="window.ReactNativeWebView.postMessage('Camera utils failed to load');">
    </script>
    <!-- Import DTW -->
    <script src="https://unpkg.com/dtw"></script>

    <style>
      html, body {
        height: 100%;
        margin: 0;
        padding: 0;
        /* allows for scrolling */
        overflow: auto;
        /* smoother scrolling in iOS */
        -webkit-overflow-scrolling: touch; 
      }
      video {
        width: 100%;
        height: auto;
      }
      canvas {
        width: 100%;
        height: auto;
        display: block;
      }
      #dtwResult {
        background-color: #f0f0f0;
        border: 2px solid #333;
        border-radius: 8px;
        padding: 15px;
        margin: 10px;
        font-family: Arial, sans-serif;
        font-size: 16px;
        text-align: center;
      }
      #compareButton {
        background-color: #4CAF50;
        color: white;
        padding: 12px 24px;
        font-size: 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        margin: 10px;
        display: block;
      }
      #compareButton:hover {
        background-color: #45a049;
      }
      #compareButton:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <h1 style="color: red; text-align: center;">HTML is Loaded and Visible!</h1>

    <!-- video component that loads and plays the video passed from React Native Expo -->
    <video id="input_vid" controls playsinline
      onerror="window.ReactNativeWebView.postMessage('Video error: ' + event.target.error.code)"
      onloadeddata="window.ReactNativeWebView.postMessage('Video loaded')"
      onplaying="window.ReactNativeWebView.postMessage('Video playing')">
    </video>
    
    <!-- draws pose landmarks over video -->
    <canvas id="output_canvas"></canvas>

    <!-- button that analyzes with pro stroke -->
    <button id="compareButton">Compare to Pro Stroke</button>

    <!-- displays dtw distance -->
    <div id="dtwResult" style="display: none;">
      <h3>Comparison Result</h3>
      <div id="dtwContent"></div>
    </div>

    <script>
      let vid = document.getElementById("input_vid");
      let canvas = document.getElementById("output_canvas");
      let canvas_context = canvas.getContext('2d');

      let pose;
      //tracks results (individual frames)
      let poseFrames = [];
      let referenceSequence;

      //function that normalizes landmarks relative to the hips
      function normalize(landmarks) {
        //grabs hip landmarks from MediaPipe
        const leftHip = landmarks[23];
        const rightHip = landmarks[24];
        //grabs shoulder landmarks from MediaPipe
        const leftShoulder = landmarks[11];
        const rightShoulder = landmarks[12];

        //calculates the midpoint between the hips (in both the x, y, z direction)
        const hipMidpoint = {
          x: (leftHip.x + rightHip.x) / 2,
          y: (leftHip.y + rightHip.y) / 2,
          //z: (leftHip.z + rightHip.z) / 2
        }

        //calculates the midpoint between the shoulders
        const shoulderMidpoint = {
          x: (leftShoulder.x + rightShoulder.x) / 2,
          y: (leftShoulder.y + rightShoulder.y) / 2,
          //z: (leftShoulder.z + rightShoulder.z) / 2
        }

        //calculates distance between the hips
        //allows for size of individual to no longer matter; allows for focus on pose/shape
        const hipWidth = Math.sqrt(
          Math.pow(leftHip.x - rightHip.x, 2) +
          Math.pow(leftHip.y - rightHip.y, 2) //+
          //Math.pow(leftHip.z - rightHip.z, 2)
        );

        //calculates the torso length, uses as scale instead of just hip width
        const torsoLength = Math.sqrt(
          Math.pow(shoulderMidpoint.x - hipMidpoint.x, 2) +
          Math.pow(shoulderMidpoint.y - hipMidpoint.y, 2) //+
          //Math.pow(shoulderMidpoint.z - hipMidpoint.z, 2)
        );

        const scale = Math.max(torsoLength, hipWidth * 0.5);
        
        return landmarks.map(landmark => ({
          //subtract midpoint to move origin to the hips
          //divide by scale to normalize for body size
          x: (landmark.x - hipMidpoint.x) / scale,
          y: (landmark.y - hipMidpoint.y) / scale,
          //z and visibility are unchanged
          //z: (landmark.z - hipMidpoint.z) / scale,
          visibility: landmark.visibility || 1.0  // Fallback for missing visibility
        }));
      }

      //function that calculates the angle between three points
      function calculateAngle(a, b, c) {
        //create vectors
        const u = {
          x: a.x - b.x,
          y: a.y - b.y,
          //z: a.z - b.z
        };
        const v = {
          x: c.x - b.x,
          y: c.y - b.y,
          //z: c.z - b.z,
        };

        //cos(theta) = dot product / product of magnitudes

        //dot product
        const dot = (u.x * v.x) + (u.y * v.y) //+ (u.z * v.z);

        //calculating the magnitudes
        const mag_u = Math.sqrt(u.x * u.x + u.y * u.y); //+ u.z * u.z);
        const mag_v = Math.sqrt(v.x * v.x + v.y * v.y); //+ v.z * v.z);

        if (mag_u === 0 || mag_v === 0) {
          return 0;
        }

        const cosAngle = Math.min(Math.max(dot / (mag_u * mag_v), -1), 1);

        //take arccos for the angle
        //returns angle in degrees
        return Math.acos(cosAngle) * (180 / Math.PI);
      }

      //helper function to calculate distance between two landmarks
      function landmarkDistance(l1, l2) {
          if (!l1 || !l2) return 0;
          //returns euclidean distance between two landmarks
          return Math.sqrt(
            Math.pow(l1.x - l2.x, 2) +
            Math.pow(l1.y - l2.y, 2)
          );
      }

      //function to create distance-invariant features
      function improvedFeatures(landmarks) {
        
        const angles = [];
        //stores key angles
        const keyAngles = [
          //right arm
          [12,14,16], //shoulder, elbow, wrist
          [14,16,18], //elbow, wrist, hand
          [11,12,24], //shoulder, shoulder, hip

          //left arm
          [11,13,15], //shoulder, elbow, wrist
          [13,15,17], //elbow, wrist, hand

          //legs
          [24,26,28], //(right) hip, knee, ankle
          [23,25,27], //(left) hip, knee, ankle

          //spine
          [11,23,25], //(left) shoulder, hip, knee
          [12,24,26], //(right) shoulder, hip, knee
        ];

        //calculates angles based on 3D landmarks for better accuracy
        function calculate3DAngle(a, b, c) {
            const u = { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };
            const v = { x: c.x - b.x, y: c.y - b.y, z: c.z - b.z };
            const dot = (u.x * v.x) + (u.y * v.y) + (u.z * v.z);
            const mag_u = Math.sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
            const mag_v = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
            if (mag_u === 0 || mag_v === 0) return 0;
            const cosAngle = Math.min(Math.max(dot / (mag_u * mag_v), -1), 1);
            return Math.acos(cosAngle) * (180 / Math.PI);
        }

        //loops through each triplet of points
        keyAngles.forEach(([a, b, c]) => {
          //checks if points exist and are mostly visible
          if (landmarks[a] && landmarks[b] && landmarks[c] && 
              landmarks[a].visibility > 0.3 && landmarks[b].visibility > 0.3 && landmarks[c].visibility > 0.3) {
            const angle = calculate3DAngle(landmarks[a], landmarks[b], landmarks[c]);
            //normalizes angles to 0-1 range
            angles.push(angle / 180.0);
          } else {
            //fallback
            //normalized 90 degrees
            angles.push(0.5);
          }
        });

        //selects torso landmarks
        const leftHip = landmarks[23];
        const rightHip = landmarks[24];
        const leftShoulder = landmarks[11];
        const rightShoulder = landmarks[12];
        
        //ensures landmarks exist
        if (!leftHip || !rightHip || !leftShoulder || !rightShoulder) {
            return null; 
        }

        //calculates midpoints for hips and shoulders
        const hipMidpoint = { x: (leftHip.x + rightHip.x) / 2, y: (leftHip.y + rightHip.y) / 2 };
        const shoulderMidpoint = { x: (leftShoulder.x + rightShoulder.x) / 2, y: (leftShoulder.y + rightShoulder.y) / 2 };
        //calculates the torso lenghth in 2D
        const torsoLength = Math.sqrt(Math.pow(shoulderMidpoint.x - hipMidpoint.x, 2) + Math.pow(shoulderMidpoint.y - hipMidpoint.y, 2));

        //avoids division by zero
        const scale = torsoLength > 0 ? torsoLength : 1;
        
        //computes wrist positions relative to hip midpoint
        //makes model distance and size invariant
        const normalizedPositions = [
            (landmarks[16].x - hipMidpoint.x) / scale, //right wrist x
            (landmarks[16].y - hipMidpoint.y) / scale, //right wrist y
            (landmarks[15].x - hipMidpoint.x) / scale, //left wrist x
            (landmarks[15].y - hipMidpoint.y) / scale, //left wrist y
        ];

        //combines joint angles and normalized wrist position
        const features = [...angles, ...normalizedPositions];
        
        //returns combined/validated feature vector
        const validFeatures = features.map(f => isFinite(f) ? f : 0);
        return validFeatures;
      }

      //function for phase detection
      function detectPhase(landmarks) {
        //right side landmarks
        const wristR = landmarks[16]; // right wrist
        const elbowR = landmarks[14]; // right elbow
        const shoulderR = landmarks[12]; //right shoulder
        const hipR = landmarks[24]; //right hip
        const kneeR = landmarks[26]; //right knee
        const ankleR = landmarks[28] //right ankle

        //left side landmarks
        const wristL = landmarks[15]; //left wrist
        const elbowL = landmarks[13]; // left elbow
        const shoulderL = landmarks[11]; //left shoulder
        const hipL = landmarks[23]; //left hip
        const kneeL = landmarks[25]; //left knee
        const ankleL = landmarks[27] //left ankle

        //right side angles
        const elbowAngleR = calculateAngle(shoulderR, elbowR, wristR);
        const shoulderAngleR = calculateAngle(elbowR, shoulderR, hipR);
        const kneeAngleR = calculateAngle(hipR, kneeR, ankleR);

        //left side angles
        const elbowAngleL = calculateAngle(shoulderL, elbowL, wristL);
        const shoulderAngleL = calculateAngle(elbowL, shoulderL, hipL);
        const kneeAngleL = calculateAngle(hipL, kneeL, ankleL);

        if (
          ((wristR.visibility < 0.75) || (wristR.z > shoulderR.z)) &&      //right wrist not visible or wrist in front of shoulders
          (shoulderL.z < shoulderR.z - 0.10)                               //slight tilt in torso
        ) {
          return "Follow-Through";
        }

        if (
          wristR.visibility > 0.5 &&
          (wristR.y > (hipR.y + 30)) &&        // wrist below hip
          wristR.z < elbowR.z &&                       // wrist closer than elbow 
          wristL.z > wristR.z && elbowL.z > wristR.z   // left arm further than right wrist
        ) {
          return "Acceleration";
        }

        if (
          wristR.visibility > 0.5 &&
          (wristR.y <= elbowR.y) &&                   // wrist above elbow
          (wristR.y < hipR.y && elbowR.y < hipR.y) && // wrist and elbow above hip
          (ankleL.z > ankleR.z) &&                   // left foot further from camera
          (shoulderL.z > shoulderR.z) &&             // left shoulder further from camera
          (elbowR.z < hipR.z)                        // arm behind hip
        ) {
          return "Preparation";
        }

        if ((wristR.visibility < 0.5 && wristL.visibility < 0.5) && //wrists not visible
            (kneeAngleL < 175 && kneeAngleR < 175)) {               //knees slightly bent
          return "Ready Position";
        }

        return "Unknown"; 
      }

      //function to find the Euclidean distance between two vectors
      function euclideanDistance(a, b) {
        //checks that inputs are null/undefined
        if (!a || !b) {
          window.ReactNativeWebView.postMessage('euclideanDistance: null input');
          return Infinity;
        }
        
        //checks that the lengths of the inputs are the same
        if (a.length !== b.length) {
          window.ReactNativeWebView.postMessage(`euclideanDistance: length mismatch ${a.length} vs ${b.length}`);
          return Infinity;
        }

        //calculates the squared difference and adds to the sum
        let sum = 0;
        for (let i = 0; i < a.length; i++) {
          //checks that the values are numbers
          if (typeof a[i] !== 'number' || typeof b[i] !== 'number') {
            window.ReactNativeWebView.postMessage(`euclideanDistance: invalid number at index ${i}: ${a[i]}, ${b[i]}`);
            return Infinity;
          }
          //checks that the values are finite
          if (!isFinite(a[i]) || !isFinite(b[i])) {
            window.ReactNativeWebView.postMessage(`euclideanDistance: non-finite number at index ${i}: ${a[i]}, ${b[i]}`);
            return Infinity;
          }
          
          //calculates the squared difference
          //adds to the sum
          const diff = a[i] - b[i];
          sum += diff * diff;
        }

        //takes the sqrt for Euclidean distance
        const result = Math.sqrt(sum);
        //checks that the final result is finite
        if (!isFinite(result)) {
          window.ReactNativeWebView.postMessage(`euclideanDistance: non-finite result ${result}`);
          return Infinity;
        }
        
        return result;
      }

      //function for DTW with better error handling
      function computeDTW(seqA, seqB) {
        try {
          //checks that the inputs aren't null/undefined
          if (!seqA || !seqB) {
            throw new Error('One or both sequences are null/undefined');
          }
          //checks that the inputs are arrays
          if (!Array.isArray(seqA) || !Array.isArray(seqB)) {
            throw new Error('Both sequences must be arrays');
          }
          //checks that the inputs are not empty
          if (seqA.length === 0 || seqB.length === 0) {
            throw new Error('Both sequences must have length > 0');
          }

          const len_A = seqA.length;
          const len_B = seqB.length;
          
          //logs predicted matrix size
          window.ReactNativeWebView.postMessage(`DTW matrix size will be: ${len_A + 1} x ${len_B + 1}`);
          
          //checks that the first few elements of both matrices are arrays/vectors
          for (let i = 0; i < Math.min(3, len_A); i++) {
            if (!Array.isArray(seqA[i])) {
              throw new Error(`seqA[${i}] is not an array: ${typeof seqA[i]}`);
            }
          }
          for (let i = 0; i < Math.min(3, len_B); i++) {
            if (!Array.isArray(seqB[i])) {
              throw new Error(`seqB[${i}] is not an array: ${typeof seqB[i]}`);
            }
          }

          //initialize 2D matrix (filled with infinity)
          const dtw = Array(len_A + 1).fill(null).map(() => Array(len_B + 1).fill(Infinity));
          dtw[0][0] = 0;

          //computation for dtw
          for (let i = 1; i <= len_A; i++) {
            for (let j = 1; j <= len_B; j++) {
              //calculates the cost/distance
              const cost = euclideanDistance(seqA[i - 1], seqB[j - 1]);
              
              //checks that the cost is finite
              if (!isFinite(cost)) {
                window.ReactNativeWebView.postMessage(`Invalid cost at i=${i}, j=${j}: ${cost}`);
                throw new Error(`Invalid cost computed at position (${i}, ${j}): ${cost}`);
              }
              
              //chooses the minimum
              const minPrev = Math.min(
                dtw[i - 1][j],     // insertion
                dtw[i][j - 1],     // deletion
                dtw[i - 1][j - 1]  // match
              );
              
              //updates the total cost
              dtw[i][j] = cost + minPrev;
              
              //checks that the result is finite
              if (!isFinite(dtw[i][j])) {
                throw new Error(`Non-finite DTW value at (${i}, ${j}): ${dtw[i][j]}`);
              }
            }
          }

          const finalResult = dtw[len_A][len_B];
          
          //logs final DTW result
          window.ReactNativeWebView.postMessage(`DTW computation successful. Result: ${finalResult}`);
          return finalResult;
          
        } catch (error) {
          window.ReactNativeWebView.postMessage(`DTW Error: ${error.message}`);
          window.ReactNativeWebView.postMessage(`DTW Stack: ${error.stack}`);
          return null;
        }
      }

      //function to display dtw results
      function displayResults(data) {
        const resultDiv = document.getElementById('dtwResult');
        const contentDiv = document.getElementById('dtwContent');
        
        if (data.error) {
          //displays error message if error occurs
          contentDiv.innerHTML = `
            <p style="color: red; font-weight: bold;">Error: ${data.error}</p>
          `;
          resultDiv.style.backgroundColor = '#ffe6e6';
          resultDiv.style.borderColor = '#ff0000';
        } else {
          //displays result
          let similarity = 'Unknown';
          let color = '#333';
          
          if (data.normalizedDistance !== null) {
            if (data.normalizedDistance < 0.1) {
              similarity = 'Excellent Match';
              color = '#4CAF50';
            } else if (data.normalizedDistance < 0.2) {
              similarity = 'Good Match';
              color = '#8BC34A';
            } else if (data.normalizedDistance < 0.3) {
              similarity = 'Fair Match';
              color = '#FFC107';
            } else {
              similarity = 'Needs Improvement';
              color = '#FF5722';
            }
          }
          
          contentDiv.innerHTML = `
            <p style="color: ${color}; font-weight: bold; font-size: 18px;">${similarity}</p>
            <p><strong>DTW Distance:</strong> ${data.distance ? data.distance.toFixed(4) : 'N/A'}</p>
            <p><strong>Normalized Score:</strong> ${data.normalizedDistance ? data.normalizedDistance.toFixed(4) : 'N/A'}</p>
            <p><strong>User Frames:</strong> ${data.originalUserFrames || 'N/A'}</p>
            <p><strong>Reference Frames:</strong> ${data.originalReferenceFrames || 'N/A'}</p>
            <p><strong>Feature Vector Length:</strong> ${data.featureVectorLength || 'N/A'}</p>
          `;
          resultDiv.style.backgroundColor = '#f0f8ff';
          resultDiv.style.borderColor = '#333';
        }
        
        //makes result visible
        resultDiv.style.display = 'block';
        
        //scrolls to result
        resultDiv.scrollIntoView({ behavior: 'smooth' });
      }

      //function takes uri sent by React Native
      window.handleVideoUri = function(video_uri) {
        //preserves the referenceSequence if it exists
        const existingReferenceSequence = window.referenceSequence;
        if (existingReferenceSequence && existingReferenceSequence.length > 0) {
          window.ReactNativeWebView.postMessage("Preserving existing referenceSequence with length: " + existingReferenceSequence.length);
          referenceSequence = existingReferenceSequence;
        }

        vid.src = video_uri;

        //creates MediaPipe pose instance
        pose = new window.Pose({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
        });
        pose.setOptions({
          modelComplexity: 1,
          smoothLandmarks: true,
          enableSegmentation: false,
          minDetectionConfidence: 0.5,
          minTrackingConfidence: 0.5
        });

        //draws landmarks and connectors
        pose.onResults(results => {
          //sets canvas size
          if (canvas.width !== vid.videoWidth || canvas.height !== vid.videoHeight) {
            canvas.width = vid.videoWidth;
            canvas.height = vid.videoHeight;
          }

          //saves canvas state
          canvas_context.save();
          //clears any previous drawings
          canvas_context.clearRect(0, 0, canvas.width, canvas.height);
          //draws the current video frame with results from MediaPipe (results.image) onto the canvas
          canvas_context.drawImage(results.image, 0, 0, canvas.width, canvas.height);

          if (results.poseLandmarks) {

            //calls functions created above
            const norm = normalize(results.poseLandmarks);
            const phase = detectPhase(norm);

            poseFrames.push({
              timestamp: vid.currentTime, //records timestamp
              phase, //records phase
              landmarks: norm //adds normalized landmark

              //landmarks: JSON.parse(JSON.stringify(results.poseLandmarks)), // deep copy of landmark
            });

            //takes landmarks pairs (either through POSE_CONNECTIONS or manually set up pairs)
            const POSE_CONNECTIONS = window.Pose?.POSE_CONNECTIONS || [
              [0,1],[1,2],[2,3],[3,7],
              [0,4],[4,5],[5,6],[6,8],
              [9,10],[11,12],
              [11,13],[13,15],[15,17],[15,19],[15,21],
              [17,19],[12,14],[14,16],[16,18],[16,20],[16,22],
              [18,20],[23,24],
              [11,23], [12,24],
              [23,25],[24,26],[25,27],[26,28],
              [27,29],[28,30],[29,31],[30,32]
            ];

            //draws the connectors (lines)
            drawConnectors(canvas_context, results.poseLandmarks, POSE_CONNECTIONS, {
              color: '#FF0000',
              lineWidth: 2,
            });
            //draws the landmarks (points)
            drawLandmarks(canvas_context, results.poseLandmarks, {
              color: '#FF0000',
              lineWidth: 1,
              circleRadius: 3,
            });

            //display phase classification on canvas
            canvas_context.font = "bold 100px Arial";
            canvas_context.fillStyle = 'yellow';
            canvas_context.fillText(`Phase: ${phase}`, 20, 50);

            //sends phase to React Native
            window.ReactNativeWebView.postMessage(JSON.stringify({
              time: vid.currentTime,
              phase: phase
            }));
          }
          //restores the canvas state after drawing
          canvas_context.restore();
        });

        // sends video frames to pose after video plays
        vid.onplay = () => {
          window.ReactNativeWebView.postMessage("Video playing, starting pose processing.");
          //starts loop by calling onVideoFrame function each frame
          requestAnimationFrame(onVideoFrame);
        };

        function onVideoFrame() {
          //if video is ready and playing
          if (vid.readyState >= 2 && !vid.paused && !vid.ended) {
            //sends video frame to pose model for processing
            pose.send({image: vid});
          }
          //continues loop by requesting next frame
          requestAnimationFrame(onVideoFrame);
        }
      };

      window.onload = function() {
        //sends pageReady to React Native to update state
        window.ReactNativeWebView.postMessage('pageReady');
        
        const button = document.getElementById("compareButton");

        button.addEventListener("click", () => {
          //disables button when loading
          button.disabled = true;
          button.textContent = 'Analyzing...';
          
          //hides/'clears' previous results
          document.getElementById('dtwResult').style.display = 'none';

          //checks that poseFrames is not empty
          if (!poseFrames.length) {
            const errorData = {
              type: "dtw",
              distance: null,
              error: "No poseFrames collected"
            };
            window.ReactNativeWebView.postMessage(JSON.stringify(errorData));
            displayResults(errorData);
            button.disabled = false;
            button.textContent = 'Compare to Pro Stroke';
            return;
          }
          //checks that referenceSequence is not empty or doesn't exist
          if (!referenceSequence || !referenceSequence.length) {
            const errorData = {
              type: "dtw",
              distance: null,
              error: "No referenceSequence available"
            };
            window.ReactNativeWebView.postMessage(JSON.stringify(errorData));
            displayResults(errorData);
            button.disabled = false;
            button.textContent = 'Compare to Pro Stroke';
            return;
          }

          try {

            /*
             * USER SEQUENCE - Use improvedFeatures for consistency
             */
            const userSequence = [];
            for (let i = 0; i < poseFrames.length; i++) {
              const frame = poseFrames[i];
              const features = improvedFeatures(frame.landmarks);
              
              // Validate features
              if (!features || features.length === 0 || features.some(f => !isFinite(f))) {
                window.ReactNativeWebView.postMessage(`Invalid user features at frame ${i}: ${JSON.stringify(features)}`);
                continue;
              }
              
              userSequence.push(features);
            }

            /*
             * REFERENCE SEQUENCE - FIXED to use same feature extraction
             */
            let processedReferenceSequence = [];
            
            if (referenceSequence.length > 0) {
              const firstRef = referenceSequence[0];
              
              // If reference has landmarks, process them the same way as user
              if (firstRef && typeof firstRef === 'object' && firstRef.landmarks) {
                processedReferenceSequence = referenceSequence.map(frame => {
                  // Ensure landmarks have visibility field
                  const landmarksWithVisibility = frame.landmarks.map(landmark => ({
                    x: landmark.x,
                    y: landmark.y, 
                    z: landmark.z,
                    visibility: landmark.visibility || 1.0
                  }));
                  
                  // Apply same feature extraction as user
                  const features = improvedFeatures(landmarksWithVisibility);
                  
                  // Validate features
                  if (!features || features.length === 0 || features.some(f => !isFinite(f))) {
                    window.ReactNativeWebView.postMessage(`Invalid reference features: ${JSON.stringify(features)}`);
                    return null;
                  }
                  
                  return features;
                }).filter(f => f !== null); // Remove invalid frames
                
              } else if (Array.isArray(firstRef)) {
                // Reference is already processed feature vectors
                processedReferenceSequence = referenceSequence.filter(frame => 
                  frame && Array.isArray(frame) && frame.every(f => isFinite(f))
                );
              } else {
                throw new Error('Unsupported reference sequence format');
              }
            } else {
              throw new Error('Empty reference sequence');
            }

            // Debug logging
            window.ReactNativeWebView.postMessage(`User sequence length: ${userSequence.length}`);
            window.ReactNativeWebView.postMessage(`Reference sequence length: ${processedReferenceSequence.length}`);
            
            if (userSequence.length > 0 && processedReferenceSequence.length > 0) {
              window.ReactNativeWebView.postMessage(`User feature vector length: ${userSequence[0].length}`);
              window.ReactNativeWebView.postMessage(`Reference feature vector length: ${processedReferenceSequence[0].length}`);
              
              // Check feature vector lengths match
              if (userSequence[0].length !== processedReferenceSequence[0].length) {
                throw new Error(`Feature vector length mismatch: user=${userSequence[0].length}, reference=${processedReferenceSequence[0].length}`);
              }
              
              // Debug first frame distance
              const firstFrameDistance = euclideanDistance(userSequence[0], processedReferenceSequence[0]);
              window.ReactNativeWebView.postMessage(`Distance between first frames: ${firstFrameDistance}`);
              
              // Log sample feature vectors for debugging
              window.ReactNativeWebView.postMessage(`User features[0]: ${JSON.stringify(userSequence[0].slice(0, 5))}...`);
              window.ReactNativeWebView.postMessage(`Reference features[0]: ${JSON.stringify(processedReferenceSequence[0].slice(0, 5))}...`);
            }

            // Compute DTW with normalized distance
            const dtwDistance = computeDTW(userSequence, processedReferenceSequence);
            
            // Normalize DTW distance by sequence lengths and feature dimensions
            let normalizedDistance = null;
            if (dtwDistance !== null && isFinite(dtwDistance)) {
              const avgSequenceLength = (userSequence.length + processedReferenceSequence.length) / 2;
              const featureDimensions = userSequence[0].length;
              //normalizedDistance = (dtwDistance / (avgSequenceLength * Math.sqrt(featureDimensions)));
              normalizedDistance = dtwDistance / (userSequence.length + referenceSequence.length);
            }
            
            //sends calculated information
            const finalResult = {
              type: "dtw",
              distance: dtwDistance,
              normalizedDistance: normalizedDistance,
              originalUserFrames: userSequence.length,
              originalReferenceFrames: processedReferenceSequence.length,
              featureVectorLength: userSequence.length > 0 ? userSequence[0].length : 0
            };

            window.ReactNativeWebView.postMessage(JSON.stringify(finalResult));
            displayResults(finalResult);
            
            window.ReactNativeWebView.postMessage('DTW computation completed successfully');
            
          } catch (error) {
            window.ReactNativeWebView.postMessage('DTW Error: ' + error.message);
            window.ReactNativeWebView.postMessage('DTW Stack: ' + error.stack);
            window.ReactNativeWebView.postMessage(JSON.stringify({
              type: "dtw",
              distance: null,
              error: error.message
            }));
          }
        });

        //logs information about pose availability
        if (window.Pose) {
          window.ReactNativeWebView.postMessage('Pose is available');
        } else {
          window.ReactNativeWebView.postMessage('Pose is not available');
        }
      };
    </script>
  </body>
</html>